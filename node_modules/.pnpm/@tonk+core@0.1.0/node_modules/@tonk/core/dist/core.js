var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _VirtualFileSystem_wasm, _Repository_wasm, _Bundle_wasm, _SyncEngine_wasm;
/**
 * Base error class for all Tonk-related errors
 */
export class TonkError extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
        this.name = 'TonkError';
    }
}
/**
 * Error thrown when connection operations fail
 */
export class ConnectionError extends TonkError {
    constructor(message) {
        super(message, 'CONNECTION_ERROR');
        this.name = 'ConnectionError';
    }
}
/**
 * Error thrown when file system operations fail
 */
export class FileSystemError extends TonkError {
    constructor(message) {
        super(message, 'FILESYSTEM_ERROR');
        this.name = 'FileSystemError';
    }
}
/**
 * Error thrown when bundle operations fail
 */
export class BundleError extends TonkError {
    constructor(message) {
        super(message, 'BUNDLE_ERROR');
        this.name = 'BundleError';
    }
}
/**
 * Virtual file system with CRDT-based synchronization.
 *
 * Provides a file-like interface for storing and retrieving documents
 * that are automatically synchronized across peers.
 *
 * @example
 * ```typescript
 * const engine = await SyncEngine.create();
 * const vfs = await engine.vfs;
 *
 * // Create a file
 * await vfs.createFile('/notes/todo.md', '# My Todo List');
 *
 * // Read it back
 * const content = await vfs.readFile('/notes/todo.md');
 * ```
 */
export class VirtualFileSystem {
    /** @internal */
    constructor(wasm) {
        _VirtualFileSystem_wasm.set(this, void 0);
        __classPrivateFieldSet(this, _VirtualFileSystem_wasm, wasm, "f");
    }
    /**
     * Create a new file with the given content.
     *
     * @param path - Absolute path where the file should be created
     * @param content - Content to write to the file (string or binary data)
     * @throws {FileSystemError} If the file already exists or path is invalid
     *
     * @example
     * ```typescript
     * // Create a text file
     * await vfs.createFile('/hello.txt', 'Hello, World!');
     *
     * // Create a binary file
     * const imageData = new Uint8Array([...]);
     * await vfs.createFile('/image.png', imageData);
     * ```
     */
    async createFile(path, content) {
        try {
            await __classPrivateFieldGet(this, _VirtualFileSystem_wasm, "f").createFile(path, content);
        }
        catch (error) {
            throw new FileSystemError(`Failed to create file at ${path}: ${error}`);
        }
    }
    /**
     * Read the contents of a file.
     *
     * @param path - Absolute path to the file
     * @returns The file contents as a string
     * @throws {FileSystemError} If the file doesn't exist or can't be read
     *
     * @example
     * ```typescript
     * const content = await vfs.readFile('/notes/todo.md');
     * console.log(content);
     * ```
     */
    async readFile(path) {
        try {
            const result = await __classPrivateFieldGet(this, _VirtualFileSystem_wasm, "f").readFile(path);
            if (result === null) {
                throw new FileSystemError(`File not found: ${path}`);
            }
            return result;
        }
        catch (error) {
            if (error instanceof FileSystemError)
                throw error;
            throw new FileSystemError(`Failed to read file at ${path}: ${error}`);
        }
    }
    /**
     * Create a new blob file with the given blob metadata, and content.
     *
     * @param path - Absolute path where the file should be created
     * @param metadata - Content to write to the file (string or binary data)
     * @param blob - Uint8Array representing the binary data
     * @throws {FileSystemError} If the file already exists or path is invalid
     *
     * @example
     * ```typescript
     * // Create a text file
     * await vfs.createFile('/media/hello.json', {name: "my-image", mime: "image/png"}, imgArray);
     * ```
     */
    async createBlobFile(path, metadata, blob) {
        try {
            const content = {
                metadata: metadata, 
                blob: blob
            };
            await __classPrivateFieldGet(this, _VirtualFileSystem_wasm, "f").createFile(path, content);
        }
        catch (error) {
            throw new FileSystemError(`Failed to create file at ${path}: ${error}`);
        }
    }
    /**
     * Read the contents of a blob file.
     *
     * @param path - Absolute path to the file
     * @returns JSON representing the blob and its metadata
     * @throws {FileSystemError} If the file doesn't exist, can't be read, or 
     * wasn't created using the `createBlobFile` function (resulting in incorrect structure)
     *
     * @example
     * ```typescript
     * const content = await vfs.readBlobFile('/media/my_video_compressed.json');
     * console.log(content.metadata.name);
     * render(content.blob, content.metadata.mime);
     * ```
     */
    async readBlobFile(path) {
        try {
            const result = await __classPrivateFieldGet(this, _VirtualFileSystem_wasm, "f").readFile(path);
            if (result === null) {
                throw new FileSystemError(`File not found: ${path}`);
            }
            const result_parsed = JSON.parse(result);
            if (!result_parsed.content.blob || !result_parsed.content.metadata) {
                throw new FileSystemError(`File not a blob type: ${path}. Try using readFile instead.`);
            }
            return result_parsed;
        }
        catch (error) {
            if (error instanceof FileSystemError)
                throw error;
            throw new FileSystemError(`Failed to read file at ${path}: ${error}`);
        }
    }
    /**
     * Delete a file.
     *
     * @param path - Absolute path to the file
     * @returns true if the file was deleted, false if it didn't exist
     * @throws {FileSystemError} If the deletion fails
     */
    async deleteFile(path) {
        try {
            return await __classPrivateFieldGet(this, _VirtualFileSystem_wasm, "f").deleteFile(path);
        }
        catch (error) {
            throw new FileSystemError(`Failed to delete file at ${path}: ${error}`);
        }
    }
    /**
     * Create a new directory.
     *
     * @param path - Absolute path where the directory should be created
     * @throws {FileSystemError} If the directory already exists or path is invalid
     *
     * @example
     * ```typescript
     * await vfs.createDirectory('/projects/my-app');
     * ```
     */
    async createDirectory(path) {
        try {
            await __classPrivateFieldGet(this, _VirtualFileSystem_wasm, "f").createDirectory(path);
        }
        catch (error) {
            throw new FileSystemError(`Failed to create directory at ${path}: ${error}`);
        }
    }
    /**
     * List the contents of a directory.
     *
     * @param path - Absolute path to the directory
     * @returns Array of directory entries
     * @throws {FileSystemError} If the directory doesn't exist or can't be read
     *
     * @example
     * ```typescript
     * const entries = await vfs.listDirectory('/projects');
     * for (const entry of entries) {
     *   console.log(`${entry.type}: ${entry.name}`);
     * }
     * ```
     */
    async listDirectory(path) {
        try {
            const entries = await __classPrivateFieldGet(this, _VirtualFileSystem_wasm, "f").listDirectory(path);
            return entries.map((entry) => ({
                name: entry.name,
                type: entry.type,
            }));
        }
        catch (error) {
            throw new FileSystemError(`Failed to list directory at ${path}: ${error}`);
        }
    }
    /**
     * Check if a file or directory exists at the given path.
     *
     * @param path - Absolute path to check
     * @returns true if something exists at the path, false otherwise
     */
    async exists(path) {
        try {
            return await __classPrivateFieldGet(this, _VirtualFileSystem_wasm, "f").exists(path);
        }
        catch (error) {
            throw new FileSystemError(`Failed to check existence of ${path}: ${error}`);
        }
    }
    /**
     * Get metadata for a file or directory.
     *
     * @param path - Absolute path to the file or directory
     * @returns Metadata object or null if the path doesn't exist
     * @throws {FileSystemError} If the metadata can't be retrieved
     *
     * @example
     * ```typescript
     * const metadata = await vfs.getMetadata('/notes/todo.md');
     * if (metadata) {
     *   console.log(`Type: ${metadata.nodeType}`);
     *   console.log(`Created: ${metadata.createdAt}`);
     *   console.log(`Modified: ${metadata.modifiedAt}`);
     * }
     * ```
     */
    async getMetadata(path) {
        try {
            const result = await __classPrivateFieldGet(this, _VirtualFileSystem_wasm, "f").getMetadata(path);
            if (result === null)
                return null;
            return {
                nodeType: result.node_type,
                createdAt: new Date(result.created_at * 1000),
                modifiedAt: new Date(result.modified_at * 1000),
            };
        }
        catch (error) {
            throw new FileSystemError(`Failed to get metadata for ${path}: ${error}`);
        }
    }
}
_VirtualFileSystem_wasm = new WeakMap();
/**
 * Repository for managing Automerge documents.
 *
 * Provides low-level access to CRDT documents for advanced use cases.
 * Most users should use the VirtualFileSystem instead.
 *
 * @example
 * ```typescript
 * const repo = await engine.repo;
 * const docId = await repo.createDocument('{"title": "My Document"}');
 * const content = await repo.findDocument(docId);
 * ```
 */
export class Repository {
    /** @internal */
    constructor(wasm) {
        _Repository_wasm.set(this, void 0);
        __classPrivateFieldSet(this, _Repository_wasm, wasm, "f");
    }
    /**
     * Get the peer ID of this repository.
     *
     * @returns The peer ID as a string
     */
    getPeerId() {
        return __classPrivateFieldGet(this, _Repository_wasm, "f").getPeerId();
    }
    /**
     * Create a new Automerge document with the given content.
     *
     * @param content - Initial content for the document (as JSON string)
     * @returns The ID of the created document
     * @throws {Error} If document creation fails
     */
    async createDocument(content) {
        return __classPrivateFieldGet(this, _Repository_wasm, "f").createDocument(content);
    }
    /**
     * Find and retrieve a document by its ID.
     *
     * @param docId - The document ID to search for
     * @returns The document content as a string, or null if not found
     * @throws {Error} If the document ID is invalid
     */
    async findDocument(docId) {
        const result = await __classPrivateFieldGet(this, _Repository_wasm, "f").findDocument(docId);
        return result === null ? null : result;
    }
}
_Repository_wasm = new WeakMap();
/**
 * Bundle for storing and retrieving binary data in a ZIP-like format.
 *
 * Bundles provide efficient storage and retrieval of key-value pairs
 * with support for prefix queries and serialization.
 *
 * @example
 * ```typescript
 * // Create a new bundle
 * const bundle = Bundle.create();
 *
 * // Store some data
 * const encoder = new TextEncoder();
 * await bundle.put('config.json', encoder.encode('{"version": 1}'));
 *
 * // Retrieve data
 * const data = await bundle.get('config.json');
 * if (data) {
 *   const decoder = new TextDecoder();
 *   console.log(decoder.decode(data));
 * }
 *
 * // Export bundle
 * const bytes = await bundle.toBytes();
 * ```
 */
export class Bundle {
    /** @internal */
    constructor(wasm) {
        _Bundle_wasm.set(this, void 0);
        __classPrivateFieldSet(this, _Bundle_wasm, wasm, "f");
    }
    /**
     * Create a new empty bundle.
     *
     * @param wasmModule - WASM module functions (for lazy loading)
     * @returns A new Bundle instance
     * @throws {BundleError} If bundle creation fails or WASM not initialized
     */
    static async create(wasmModule) {
        try {
            const { create_bundle } = wasmModule || (await import('./tonk_core.js'));
            return new Bundle(create_bundle());
        }
        catch (error) {
            throw new BundleError(`Failed to create bundle: ${error}`);
        }
    }
    /**
     * Create a bundle from existing data.
     *
     * @param data - Binary data representing a serialized bundle
     * @param wasmModule - WASM module functions (for lazy loading)
     * @returns A new Bundle instance
     * @throws {BundleError} If the data is invalid, corrupted, or WASM not initialized
     */
    static async fromBytes(data, wasmModule) {
        try {
            const { create_bundle_from_bytes } = wasmModule || (await import('./tonk_core.js'));
            return new Bundle(create_bundle_from_bytes(data));
        }
        catch (error) {
            throw new BundleError(`Failed to create bundle from bytes: ${error}`);
        }
    }
    /**
     * Store a value in the bundle.
     *
     * @param key - The key to store the value under
     * @param value - Binary data to store
     * @throws {BundleError} If the operation fails
     */
    async put(key, value) {
        try {
            await __classPrivateFieldGet(this, _Bundle_wasm, "f").put(key, value);
        }
        catch (error) {
            throw new BundleError(`Failed to put key ${key}: ${error}`);
        }
    }
    /**
     * Retrieve a value from the bundle.
     *
     * @param key - The key to look up
     * @returns The stored data, or null if the key doesn't exist
     * @throws {BundleError} If the operation fails
     */
    async get(key) {
        try {
            const result = await __classPrivateFieldGet(this, _Bundle_wasm, "f").get(key);
            return result === null ? null : result;
        }
        catch (error) {
            throw new BundleError(`Failed to get key ${key}: ${error}`);
        }
    }
    /**
     * Delete a value from the bundle.
     *
     * @param key - The key to delete
     * @throws {BundleError} If the operation fails
     */
    async delete(key) {
        try {
            await __classPrivateFieldGet(this, _Bundle_wasm, "f").delete(key);
        }
        catch (error) {
            throw new BundleError(`Failed to delete key ${key}: ${error}`);
        }
    }
    /**
     * Get all entries with keys that start with the given prefix.
     *
     * @param prefix - The prefix to search for
     * @returns Array of matching entries
     * @throws {BundleError} If the operation fails
     *
     * @example
     * ```typescript
     * // Get all config files
     * const configs = await bundle.getPrefix('config/');
     * for (const entry of configs) {
     *   console.log(`${entry.key}: ${entry.value.byteLength} bytes`);
     * }
     * ```
     */
    async getPrefix(prefix) {
        try {
            const results = await __classPrivateFieldGet(this, _Bundle_wasm, "f").getPrefix(prefix);
            return results.map((entry) => ({
                key: entry.key,
                value: entry.value,
            }));
        }
        catch (error) {
            throw new BundleError(`Failed to get prefix ${prefix}: ${error}`);
        }
    }
    /**
     * List all keys in the bundle.
     *
     * @returns Array of all keys
     * @throws {BundleError} If the operation fails
     */
    async listKeys() {
        try {
            return await __classPrivateFieldGet(this, _Bundle_wasm, "f").listKeys();
        }
        catch (error) {
            throw new BundleError(`Failed to list keys: ${error}`);
        }
    }
    /**
     * Serialize the bundle to binary data.
     *
     * @returns The serialized bundle data
     * @throws {BundleError} If serialization fails
     */
    async toBytes() {
        try {
            return await __classPrivateFieldGet(this, _Bundle_wasm, "f").toBytes();
        }
        catch (error) {
            throw new BundleError(`Failed to serialize bundle: ${error}`);
        }
    }
    /**
     * Free the WASM memory associated with this bundle.
     * Call this when you're done with the bundle to prevent memory leaks.
     */
    free() {
        __classPrivateFieldGet(this, _Bundle_wasm, "f").free();
    }
}
_Bundle_wasm = new WeakMap();
/**
 * Main synchronization engine for Tonk.
 *
 * The SyncEngine manages peer-to-peer synchronization, WebSocket connections,
 * and provides access to the virtual file system and repository.
 *
 * @example
 * ```typescript
 * // Create a sync engine with auto-generated peer ID
 * const engine = await SyncEngine.create();
 *
 * // Or create with a specific peer ID
 * const engine = await SyncEngine.createWithPeerId('my-peer-id');
 *
 * // Connect to a sync server
 * await engine.connectWebsocket('ws://localhost:8080');
 *
 * // Access the virtual file system
 * const vfs = await engine.vfs;
 * ```
 */
export class SyncEngine {
    /** @internal */
    constructor(wasm) {
        _SyncEngine_wasm.set(this, void 0);
        __classPrivateFieldSet(this, _SyncEngine_wasm, wasm, "f");
    }
    /**
     * Create a new sync engine with an auto-generated peer ID.
     *
     * @param wasmModule - WASM module functions (for lazy loading)
     * @returns A new SyncEngine instance
     * @throws {Error} If engine creation fails or WASM not initialized
     */
    static async create(wasmModule) {
        const { create_sync_engine } = wasmModule || (await import('./tonk_core.js'));
        const wasm = await create_sync_engine();
        return new SyncEngine(wasm);
    }
    /**
     * Create a new sync engine with a specific peer ID.
     *
     * @param peerId - The peer ID to use
     * @param wasmModule - WASM module functions (for lazy loading)
     * @returns A new SyncEngine instance
     * @throws {Error} If engine creation fails, peer ID is invalid, or WASM not initialized
     */
    static async createWithPeerId(peerId, wasmModule) {
        const { create_sync_engine_with_peer_id } = wasmModule || (await import('./tonk_core.js'));
        const wasm = await create_sync_engine_with_peer_id(peerId);
        return new SyncEngine(wasm);
    }
    /**
     * Get the peer ID of this sync engine.
     *
     * @returns The peer ID as a string
     */
    getPeerId() {
        return __classPrivateFieldGet(this, _SyncEngine_wasm, "f").getPeerId();
    }
    /**
     * Get the virtual file system instance.
     *
     * @returns The VirtualFileSystem instance
     */
    async getVfs() {
        return __classPrivateFieldGet(this, _SyncEngine_wasm, "f").getVfs().then(wasm => new VirtualFileSystem(wasm));
    }
    /**
     * Get the repository instance.
     *
     * @returns The Repository instance
     */
    async getRepo() {
        return __classPrivateFieldGet(this, _SyncEngine_wasm, "f").getRepo().then(wasm => new Repository(wasm));
    }
    /**
     * Connect to a WebSocket server for real-time synchronization.
     *
     * @param url - WebSocket URL to connect to
     * @throws {ConnectionError} If connection fails
     *
     * @example
     * ```typescript
     * await engine.connectWebsocket('ws://sync.example.com:8080');
     * ```
     */
    async connectWebsocket(url) {
        try {
            await __classPrivateFieldGet(this, _SyncEngine_wasm, "f").connectWebsocket(url);
        }
        catch (error) {
            throw new ConnectionError(`Failed to connect to ${url}: ${error}`);
        }
    }
    /**
     * Free the WASM memory associated with this engine.
     * Call this when you're done with the engine to prevent memory leaks.
     */
    free() {
        __classPrivateFieldGet(this, _SyncEngine_wasm, "f").free();
    }
}
_SyncEngine_wasm = new WeakMap();
/**
 * Factory functions that can work with either direct or lazy-loaded WASM modules
 */
export function createFactoryFunctions(wasmModule) {
    return {
        /**
         * Create a new sync engine with an auto-generated peer ID.
         *
         * @returns A new SyncEngine instance
         * @throws {Error} If engine creation fails
         */
        createSyncEngine: () => SyncEngine.create(wasmModule),
        /**
         * Create a new sync engine with a specific peer ID.
         *
         * @param peerId - The peer ID to use
         * @returns A new SyncEngine instance
         * @throws {Error} If engine creation fails or peer ID is invalid
         */
        createSyncEngineWithPeerId: (peerId) => SyncEngine.createWithPeerId(peerId, wasmModule),
        /**
         * Create a new empty bundle.
         *
         * @returns A new Bundle instance
         * @throws {BundleError} If bundle creation fails
         */
        createBundle: () => Bundle.create(wasmModule),
        /**
         * Create a bundle from existing data.
         *
         * @param data - Binary data representing a serialized bundle
         * @returns A new Bundle instance
         * @throws {BundleError} If the data is invalid or corrupted
         */
        createBundleFromBytes: (data) => Bundle.fromBytes(data, wasmModule),
    };
}
