import type { WasmVfs, WasmRepo, WasmBundle } from './tonk_core.js';
/**
 * Metadata for a file or directory node in the virtual file system
 */
export interface NodeMetadata {
    /** Type of the node - either 'directory' or 'document' */
    nodeType: 'directory' | 'document';
    /** Creation timestamp */
    createdAt: Date;
    /** Last modification timestamp */
    modifiedAt: Date;
}
/**
 * Entry in a directory listing
 */
export interface DirectoryEntry {
    /** Name of the file or directory */
    name: string;
    /** Type of the entry */
    type: 'directory' | 'document';
}
/**
 * Entry returned by bundle prefix queries
 */
export interface BundleEntry {
    /** Key of the entry */
    key: string;
    /** Binary data stored at this key */
    value: Uint8Array;
}
/**
 * Configuration options for Tonk initialization
 */
export interface TonkConfig {
    /** Custom path to the WASM module */
    wasmPath?: string;
}
/**
 * Base error class for all Tonk-related errors
 */
export declare class TonkError extends Error {
    code?: string | undefined;
    constructor(message: string, code?: string | undefined);
}
/**
 * Error thrown when connection operations fail
 */
export declare class ConnectionError extends TonkError {
    constructor(message: string);
}
/**
 * Error thrown when file system operations fail
 */
export declare class FileSystemError extends TonkError {
    constructor(message: string);
}
/**
 * Error thrown when bundle operations fail
 */
export declare class BundleError extends TonkError {
    constructor(message: string);
}
/**
 * Virtual file system with CRDT-based synchronization.
 *
 * Provides a file-like interface for storing and retrieving documents
 * that are automatically synchronized across peers.
 *
 * @example
 * ```typescript
 * const engine = await SyncEngine.create();
 * const vfs = await engine.vfs;
 *
 * // Create a file
 * await vfs.createFile('/notes/todo.md', '# My Todo List');
 *
 * // Read it back
 * const content = await vfs.readFile('/notes/todo.md');
 * ```
 */
export declare class VirtualFileSystem {
    #private;
    /** @internal */
    constructor(wasm: WasmVfs);
    /**
     * Create a new file with the given content.
     *
     * @param path - Absolute path where the file should be created
     * @param content - Content to write to the file (string or binary data)
     * @throws {FileSystemError} If the file already exists or path is invalid
     *
     * @example
     * ```typescript
     * // Create a text file
     * await vfs.createFile('/hello.txt', 'Hello, World!');
     *
     * // Create a binary file
     * const imageData = new Uint8Array([...]);
     * await vfs.createFile('/image.png', imageData);
     * ```
     */
    createFile(path: string, content: string | Uint8Array): Promise<void>;
    /**
     * Read the contents of a file.
     *
     * @param path - Absolute path to the file
     * @returns The file contents as a string
     * @throws {FileSystemError} If the file doesn't exist or can't be read
     *
     * @example
     * ```typescript
     * const content = await vfs.readFile('/notes/todo.md');
     * console.log(content);
     * ```
     */
    readFile(path: string): Promise<string>;
    /**
     * Delete a file.
     *
     * @param path - Absolute path to the file
     * @returns true if the file was deleted, false if it didn't exist
     * @throws {FileSystemError} If the deletion fails
     */
    deleteFile(path: string): Promise<boolean>;
    /**
     * Create a new directory.
     *
     * @param path - Absolute path where the directory should be created
     * @throws {FileSystemError} If the directory already exists or path is invalid
     *
     * @example
     * ```typescript
     * await vfs.createDirectory('/projects/my-app');
     * ```
     */
    createDirectory(path: string): Promise<void>;
    /**
     * List the contents of a directory.
     *
     * @param path - Absolute path to the directory
     * @returns Array of directory entries
     * @throws {FileSystemError} If the directory doesn't exist or can't be read
     *
     * @example
     * ```typescript
     * const entries = await vfs.listDirectory('/projects');
     * for (const entry of entries) {
     *   console.log(`${entry.type}: ${entry.name}`);
     * }
     * ```
     */
    listDirectory(path: string): Promise<DirectoryEntry[]>;
    /**
     * Check if a file or directory exists at the given path.
     *
     * @param path - Absolute path to check
     * @returns true if something exists at the path, false otherwise
     */
    exists(path: string): Promise<boolean>;
    /**
     * Get metadata for a file or directory.
     *
     * @param path - Absolute path to the file or directory
     * @returns Metadata object or null if the path doesn't exist
     * @throws {FileSystemError} If the metadata can't be retrieved
     *
     * @example
     * ```typescript
     * const metadata = await vfs.getMetadata('/notes/todo.md');
     * if (metadata) {
     *   console.log(`Type: ${metadata.nodeType}`);
     *   console.log(`Created: ${metadata.createdAt}`);
     *   console.log(`Modified: ${metadata.modifiedAt}`);
     * }
     * ```
     */
    getMetadata(path: string): Promise<NodeMetadata | null>;
}
/**
 * Repository for managing Automerge documents.
 *
 * Provides low-level access to CRDT documents for advanced use cases.
 * Most users should use the VirtualFileSystem instead.
 *
 * @example
 * ```typescript
 * const repo = await engine.repo;
 * const docId = await repo.createDocument('{"title": "My Document"}');
 * const content = await repo.findDocument(docId);
 * ```
 */
export declare class Repository {
    #private;
    /** @internal */
    constructor(wasm: WasmRepo);
    /**
     * Get the peer ID of this repository.
     *
     * @returns The peer ID as a string
     */
    getPeerId(): Promise<string>;
    /**
     * Create a new Automerge document with the given content.
     *
     * @param content - Initial content for the document (as JSON string)
     * @returns The ID of the created document
     * @throws {Error} If document creation fails
     */
    createDocument(content: string): Promise<string>;
    /**
     * Find and retrieve a document by its ID.
     *
     * @param docId - The document ID to search for
     * @returns The document content as a string, or null if not found
     * @throws {Error} If the document ID is invalid
     */
    findDocument(docId: string): Promise<string | null>;
}
/**
 * Bundle for storing and retrieving binary data in a ZIP-like format.
 *
 * Bundles provide efficient storage and retrieval of key-value pairs
 * with support for prefix queries and serialization.
 *
 * @example
 * ```typescript
 * // Create a new bundle
 * const bundle = Bundle.create();
 *
 * // Store some data
 * const encoder = new TextEncoder();
 * await bundle.put('config.json', encoder.encode('{"version": 1}'));
 *
 * // Retrieve data
 * const data = await bundle.get('config.json');
 * if (data) {
 *   const decoder = new TextDecoder();
 *   console.log(decoder.decode(data));
 * }
 *
 * // Export bundle
 * const bytes = await bundle.toBytes();
 * ```
 */
export declare class Bundle {
    #private;
    /** @internal */
    constructor(wasm: WasmBundle);
    /**
     * Create a new empty bundle.
     *
     * @param wasmModule - WASM module functions (for lazy loading)
     * @returns A new Bundle instance
     * @throws {BundleError} If bundle creation fails or WASM not initialized
     */
    static create(wasmModule?: any): Promise<Bundle>;
    /**
     * Create a bundle from existing data.
     *
     * @param data - Binary data representing a serialized bundle
     * @param wasmModule - WASM module functions (for lazy loading)
     * @returns A new Bundle instance
     * @throws {BundleError} If the data is invalid, corrupted, or WASM not initialized
     */
    static fromBytes(data: Uint8Array, wasmModule?: any): Promise<Bundle>;
    /**
     * Store a value in the bundle.
     *
     * @param key - The key to store the value under
     * @param value - Binary data to store
     * @throws {BundleError} If the operation fails
     */
    put(key: string, value: Uint8Array): Promise<void>;
    /**
     * Retrieve a value from the bundle.
     *
     * @param key - The key to look up
     * @returns The stored data, or null if the key doesn't exist
     * @throws {BundleError} If the operation fails
     */
    get(key: string): Promise<Uint8Array | null>;
    /**
     * Delete a value from the bundle.
     *
     * @param key - The key to delete
     * @throws {BundleError} If the operation fails
     */
    delete(key: string): Promise<void>;
    /**
     * Get all entries with keys that start with the given prefix.
     *
     * @param prefix - The prefix to search for
     * @returns Array of matching entries
     * @throws {BundleError} If the operation fails
     *
     * @example
     * ```typescript
     * // Get all config files
     * const configs = await bundle.getPrefix('config/');
     * for (const entry of configs) {
     *   console.log(`${entry.key}: ${entry.value.byteLength} bytes`);
     * }
     * ```
     */
    getPrefix(prefix: string): Promise<BundleEntry[]>;
    /**
     * List all keys in the bundle.
     *
     * @returns Array of all keys
     * @throws {BundleError} If the operation fails
     */
    listKeys(): Promise<string[]>;
    /**
     * Serialize the bundle to binary data.
     *
     * @returns The serialized bundle data
     * @throws {BundleError} If serialization fails
     */
    toBytes(): Promise<Uint8Array>;
    /**
     * Free the WASM memory associated with this bundle.
     * Call this when you're done with the bundle to prevent memory leaks.
     */
    free(): void;
}
/**
 * Main synchronization engine for Tonk.
 *
 * The SyncEngine manages peer-to-peer synchronization, WebSocket connections,
 * and provides access to the virtual file system and repository.
 *
 * @example
 * ```typescript
 * // Create a sync engine with auto-generated peer ID
 * const engine = await SyncEngine.create();
 *
 * // Or create with a specific peer ID
 * const engine = await SyncEngine.createWithPeerId('my-peer-id');
 *
 * // Connect to a sync server
 * await engine.connectWebsocket('ws://localhost:8080');
 *
 * // Access the virtual file system
 * const vfs = await engine.vfs;
 * ```
 */
export declare class SyncEngine {
    #private;
    /** @internal */
    private constructor();
    /**
     * Create a new sync engine with an auto-generated peer ID.
     *
     * @param wasmModule - WASM module functions (for lazy loading)
     * @returns A new SyncEngine instance
     * @throws {Error} If engine creation fails or WASM not initialized
     */
    static create(wasmModule?: any): Promise<SyncEngine>;
    /**
     * Create a new sync engine with a specific peer ID.
     *
     * @param peerId - The peer ID to use
     * @param wasmModule - WASM module functions (for lazy loading)
     * @returns A new SyncEngine instance
     * @throws {Error} If engine creation fails, peer ID is invalid, or WASM not initialized
     */
    static createWithPeerId(peerId: string, wasmModule?: any): Promise<SyncEngine>;
    /**
     * Get the peer ID of this sync engine.
     *
     * @returns The peer ID as a string
     */
    getPeerId(): Promise<string>;
    /**
     * Get the virtual file system instance.
     *
     * @returns The VirtualFileSystem instance
     */
    getVfs(): Promise<VirtualFileSystem>;
    /**
     * Get the repository instance.
     *
     * @returns The Repository instance
     */
    getRepo(): Promise<Repository>;
    /**
     * Connect to a WebSocket server for real-time synchronization.
     *
     * @param url - WebSocket URL to connect to
     * @throws {ConnectionError} If connection fails
     *
     * @example
     * ```typescript
     * await engine.connectWebsocket('ws://sync.example.com:8080');
     * ```
     */
    connectWebsocket(url: string): Promise<void>;
    /**
     * Free the WASM memory associated with this engine.
     * Call this when you're done with the engine to prevent memory leaks.
     */
    free(): void;
}
/**
 * Factory functions that can work with either direct or lazy-loaded WASM modules
 */
export declare function createFactoryFunctions(wasmModule?: any): {
    /**
     * Create a new sync engine with an auto-generated peer ID.
     *
     * @returns A new SyncEngine instance
     * @throws {Error} If engine creation fails
     */
    createSyncEngine: () => Promise<SyncEngine>;
    /**
     * Create a new sync engine with a specific peer ID.
     *
     * @param peerId - The peer ID to use
     * @returns A new SyncEngine instance
     * @throws {Error} If engine creation fails or peer ID is invalid
     */
    createSyncEngineWithPeerId: (peerId: string) => Promise<SyncEngine>;
    /**
     * Create a new empty bundle.
     *
     * @returns A new Bundle instance
     * @throws {BundleError} If bundle creation fails
     */
    createBundle: () => Promise<Bundle>;
    /**
     * Create a bundle from existing data.
     *
     * @param data - Binary data representing a serialized bundle
     * @returns A new Bundle instance
     * @throws {BundleError} If the data is invalid or corrupted
     */
    createBundleFromBytes: (data: Uint8Array) => Promise<Bundle>;
};
//# sourceMappingURL=core.d.ts.map