{"version":3,"sources":["../src/lib/tonkAuth.ts","../src/utils/result.ts","../src/utils/utils.ts","../package.json","../src/lib/clerkClient.ts","../src/lib/tokenCache.ts","../src/lib/localhostServer.ts"],"sourcesContent":["import { createPublicKey } from \"node:crypto\";\nimport type {\n  SessionResource,\n  SignInResource,\n  UserResource,\n} from \"@clerk/types\";\nimport { type JWTPayload, jwtVerify } from \"jose\";\nimport open from \"open\";\nimport { err, ok, type Result } from \"@/utils/result\";\nimport { delay } from \"@/utils/utils\";\nimport { version } from \"../../package.json\";\nimport { clerkClient } from \"./clerkClient\";\nimport { createLocalhostAuthServer } from \"./localhostServer\";\nimport {\n  clearStoredAuth,\n  createSubscriptionTokenCache,\n  createTokenCache,\n} from \"./tokenCache\";\n\n/**\n * Wrapper around Clerk Auth + Tonk Backend\n */\n\nconst TONK_BASE_URL = process.env.TONK_BASE_URL || \"http://localhost:5173\"; // @dev: localhost to enable vite dev on OSX\n\nconst TONK_AUTH_URL = `${TONK_BASE_URL}/dashboard/auth-cli`;\nconst EXPECTED_ISSUER = `${TONK_BASE_URL}`;\nconst TOKEN_SUBSCRIPTION_URL = `${TONK_BASE_URL}/api/v1/cli-subscription`;\n\nif (!process.env.TONK_PUBLIC_KEY) {\n  throw new Error(\"TONK_PUBLIC_KEY environment variable not set\");\n}\n\nconst publicKey = createPublicKey(\n  Buffer.from(process.env.TONK_PUBLIC_KEY, \"base64\").toString(\"utf-8\"),\n);\n\ntype CliTokenPayload = JWTPayload & {\n  subscription_active: boolean;\n  plan: string;\n};\n\ntype SubscriptionStatus = {\n  active: boolean;\n  data: CliTokenPayload | null;\n};\n\n/**\n * Configuration options for TonkAuth client\n *\n * @example\n * ```typescript\n * const options: TonkAuthOptions = {\n *   // Called when subscription expires or becomes inactive\n *   onSubscriptionDisabled: () => {\n *     console.log('⚠️ Your subscription has expired!');\n *     process.exit(1);\n *   },\n *\n *   // Check subscription every 30 seconds instead of default 1 minute\n *   checkInterval: 30 * 1000,\n *\n *   // Retry failed requests up to 5 times instead of default 3\n *   retryAttempts: 5,\n *\n *   // Wait 2 seconds between retries instead of default 1 second\n *   retryDelay: 2000\n * };\n *\n * const auth = await TonkAuth(options);\n * ```\n */\nexport type TonkAuthOptions = {\n  /**\n   * Callback function executed when user's subscription becomes inactive\n   *\n   * This is called during periodic checks if the subscription status\n   * changes from active to inactive. Useful for displaying warnings\n   * or gracefully shutting down CLI tools.\n   *\n   * @type {() => void}\n   * @optional\n   * @default undefined\n   */\n  onSubscriptionDisabled?: () => void;\n\n  /**\n   * Interval for periodic subscription status checks (in milliseconds)\n   *\n   * The client will automatically check subscription status at this interval\n   * to ensure the user hasn't downgraded or cancelled their subscription.\n   *\n   * @type {number}\n   * @optional\n   * @default 60000 (1 minute)\n   */\n  checkInterval?: number;\n\n  /**\n   * Maximum number of retry attempts for failed API requests\n   *\n   * When subscription checks or authentication requests fail due to network\n   * issues, the client will retry up to this many times before giving up.\n   *\n   * @type {number}\n   * @optional\n   * @default 3\n   */\n  retryAttempts?: number;\n\n  /**\n   * Base delay between retry attempts (in milliseconds)\n   *\n   * Each retry will wait: `retryDelay * attemptNumber` milliseconds.\n   * For example, with retryDelay=1000: 1st retry waits 1s, 2nd waits 2s, etc.\n   *\n   * @type {number}\n   * @optional\n   * @default 1000 (1 second)\n   */\n  retryDelay?: number;\n};\n\nclass _TonkAuth implements TonkAuthClient {\n  private _activeSubscription: boolean = false;\n  private _options: Required<TonkAuthOptions>;\n  private _checkIntervalId: NodeJS.Timeout | null = null;\n  private _subscriptionData: CliTokenPayload | null = null;\n  __initialized: boolean = false;\n\n  constructor(options: TonkAuthOptions = {}) {\n    this._options = {\n      onSubscriptionDisabled: options.onSubscriptionDisabled || (() => {}),\n      checkInterval: options.checkInterval || 60 * 1000, // 1 minute\n      retryAttempts: options.retryAttempts || 3,\n      retryDelay: options.retryDelay || 1000,\n    };\n\n    this._initialize();\n  }\n\n  private async _initialize(): Promise<void> {\n    try {\n      // Check if user is already logged in\n      if (clerkClient.session) {\n        await this._updateSubscriptionStatus();\n      }\n\n      // Set up periodic checks\n      this._setupPeriodicCheck();\n      this.__initialized = true;\n    } catch (error) {\n      console.error(\"[TonkAuth] initialization failed:\", error);\n      throw new Error(\"TonkAuth initialization failed\");\n    }\n  }\n\n  private _setupPeriodicCheck(): void {\n    if (this._checkIntervalId) {\n      clearInterval(this._checkIntervalId);\n    }\n\n    this._checkIntervalId = setInterval(async () => {\n      if (clerkClient.session) {\n        await this._updateSubscriptionStatus();\n      }\n    }, this._options.checkInterval);\n  }\n\n  private async _updateSubscriptionStatus(): Promise<void> {\n    const cache = await createSubscriptionTokenCache(\"tonk-cli\");\n    const token = cache.getToken();\n\n    if (token) {\n      const status = JSON.parse(token) as SubscriptionStatus;\n      // check if active and not expired\n      if (\n        status.active &&\n        !(status.data?.exp && status.data.exp < Date.now() / 1000)\n      ) {\n        this._activeSubscription = status.active;\n        this._subscriptionData = status.data;\n        return;\n      }\n    }\n    await cache.clearToken();\n    try {\n      // fetch subscription token\n      const result = await this._fetchSubscriptionTokenWithRetry();\n\n      if (result.ok) {\n        const wasActive = this._activeSubscription;\n        this._activeSubscription = result.value.active;\n        this._subscriptionData = result.value.data;\n        await cache.clearToken();\n        if (result.value.data) {\n          await cache.saveToken(JSON.stringify(result.value));\n        }\n\n        // Call callback if subscription became inactive\n        if (wasActive && !this._activeSubscription) {\n          this._options.onSubscriptionDisabled();\n        }\n      } else {\n        // Gracefully handle errors - don't update status on connection issues\n        console.warn(\n          \"Failed to update subscription status:\",\n          result.error.message,\n          `URL[${TONK_BASE_URL}]`,\n        );\n      }\n    } catch (error) {\n      console.warn(\"Error updating subscription status:\", error);\n    }\n  }\n\n  private async _fetchSubscriptionTokenWithRetry(): Promise<\n    Result<SubscriptionStatus, Error>\n  > {\n    for (let attempt = 1; attempt <= this._options.retryAttempts; attempt++) {\n      try {\n        const result = await this._fetchSubscriptionToken();\n        if (result.ok) {\n          return result;\n        }\n\n        // Don't retry on authentication errors\n        if (\n          result.error.message.includes(\"No active Clerk session\") ||\n          result.error.message.includes(\"Failed to obtain session token\")\n        ) {\n          return result;\n        }\n\n        // Don't retry on subscription inactive (402)\n        if (result.error.message.includes(\"Subscription inactive\")) {\n          return {\n            ok: true,\n            value: {\n              active: false,\n              data: null,\n            },\n          };\n        }\n\n        // Retry on connection/server errors\n        if (attempt < this._options.retryAttempts) {\n          await delay(this._options.retryDelay * attempt);\n          continue;\n        }\n\n        return result;\n      } catch (error) {\n        if (attempt === this._options.retryAttempts) {\n          return err(error as Error);\n        }\n        await delay(this._options.retryDelay * attempt);\n      }\n    }\n\n    return err(new Error(\"Max retry attempts exceeded\"));\n  }\n\n  private async _fetchSubscriptionToken(): Promise<\n    Result<SubscriptionStatus, Error>\n  > {\n    try {\n      const clerk = clerkClient;\n\n      if (!clerk.session) {\n        return err(new Error(\"No active Clerk session\"));\n      }\n\n      const session = await clerk.session.getToken();\n      if (!session) {\n        return err(new Error(\"Failed to obtain session token\"));\n      }\n\n      const res = await fetch(TOKEN_SUBSCRIPTION_URL, {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${session}`,\n        },\n      });\n\n      if (!res.ok) {\n        return err(new Error(`Token endpoint error ${res.status}`));\n      }\n\n      const responseData = (await res.json()) as {\n        token?: string;\n        status?: number;\n        code?: string;\n      };\n\n      // Check if subscription is inactive (API returns { status: 402, code: \"INACTIVE\" })\n\n      if (responseData.status === 402) {\n        return ok({ active: false, data: null });\n      }\n\n      if (!responseData.token) {\n        return err(new Error(\"No token in response\"));\n      }\n\n      const token = responseData.token;\n      const verifyResult = await this._verifyCliToken(token);\n\n      if (!verifyResult.ok) {\n        return err(verifyResult.error);\n      }\n\n      const cache = await createTokenCache(\"tonk-cli\");\n      await cache.saveToken(token);\n\n      return ok(verifyResult.value);\n    } catch (error) {\n      return err(error as Error);\n    }\n  }\n\n  private async _verifyCliToken(\n    raw: string,\n  ): Promise<Result<SubscriptionStatus, Error>> {\n    try {\n      const { payload } = await jwtVerify<CliTokenPayload>(raw, publicKey, {\n        audience: \"tonk-cli\",\n        issuer: [EXPECTED_ISSUER],\n      });\n\n      if (!payload.subscription_active) {\n        return ok({ active: false, data: null });\n      }\n\n      return ok({ active: true, data: payload });\n    } catch (error) {\n      return err(error as Error);\n    }\n  }\n\n  // Public API\n\n  /**\n   * Get the current subscription status\n   */\n  get activeSubscription(): boolean {\n    return this._activeSubscription;\n  }\n\n  get isSignedIn(): boolean {\n    return clerkClient.isSignedIn;\n  }\n\n  get email(): string {\n    return this.__user?.primaryEmailAddress?.emailAddress ?? \"unknown\";\n  }\n\n  get friendlyName(): string | null {\n    if (!this.__user) return null;\n    return (\n      this.__user?.firstName ??\n      this.__user?.lastName ??\n      this.__user?.username ??\n      this.email\n    );\n  }\n\n  get version(): string {\n    return version;\n  }\n\n  get __user(): UserResource | null {\n    return clerkClient.user ?? null;\n  }\n\n  get __session(): SessionResource | null {\n    return clerkClient.session ?? null;\n  }\n\n  /**\n   * Login user and automatically check subscription status\n   */\n  async login(): Promise<\n    Result<{ data: (typeof clerkClient)[\"user\"]; subscription: boolean }, Error>\n  > {\n    let localhostServer: Awaited<\n      ReturnType<typeof createLocalhostAuthServer>\n    > | null = null;\n\n    try {\n      localhostServer = await createLocalhostAuthServer();\n      const url = encodeURI(\n        `${TONK_AUTH_URL}?redirectUrl=${localhostServer.LOCALHOST_REDIRECT_URL}`,\n      );\n\n      await open(url);\n      const token = await localhostServer.listenForAuthRedirect();\n\n      const res = (await clerkClient.client?.signIn.create({\n        strategy: \"ticket\",\n        ticket: token,\n      })) as SignInResource | undefined;\n\n      if (!res) {\n        return err(new Error(\"Sign-in request did not return a response\"));\n      }\n\n      if (res.status !== \"complete\") {\n        return err(new Error(`Flow did not complete: ${JSON.stringify(res)}`));\n      }\n\n      // Mark the newly created session as active so that the current\n      // Clerk instance immediately reflects the authenticated state.\n      if (res.createdSessionId) {\n        await clerkClient.setActive({ session: res.createdSessionId });\n      }\n\n      // Ensure in-memory resources are refreshed\n      await clerkClient.session?.reload();\n      await clerkClient.client?.reload();\n\n      // Immediately check subscription status after login\n      await this._updateSubscriptionStatus();\n\n      return ok({\n        data: clerkClient.user,\n        subscription: this._activeSubscription,\n      });\n    } catch (error) {\n      return err(error as Error);\n    } finally {\n      // Always cleanup the server\n      if (localhostServer) {\n        localhostServer.cleanup();\n      }\n    }\n  }\n\n  /**\n   * Logout user and cleanup\n   */\n  async logout(): Promise<Result<string, Error>> {\n    try {\n      clerkClient.client?.clearCache();\n\n      if (clerkClient.session) {\n        await clerkClient.signOut();\n      }\n\n      // Clear any locally stored auth data\n      await clearStoredAuth();\n\n      // Reset subscription status\n      this._activeSubscription = false;\n      this._subscriptionData = null;\n\n      return ok(\"Logged out successfully\");\n    } catch (error) {\n      return err(error as Error);\n    }\n  }\n\n  /**\n   * Cleanup resources and stop periodic checks\n   */\n  destroy(): void {\n    if (this._checkIntervalId) {\n      clearInterval(this._checkIntervalId);\n      this._checkIntervalId = null;\n    }\n  }\n}\n\n/**\n * `tonk-auth` Client Interface\n *\n * Provides authentication and subscription management for the Tonk CLI.\n * This is the main interface returned by the TonkAuth factory function.\n *\n * @interface TonkAuthClient\n * @example\n * ```typescript\n * import { TonkAuth } from 'tonk-auth';\n *\n * const auth = await TonkAuth({\n *   onSubscriptionDisabled: () => console.log('Subscription expired!'),\n *   checkInterval: 60000 // Check every minute\n * });\n *\n * // Check authentication status\n * if (!auth.isSignedIn) {\n *   const result = await auth.login();\n *   if (result.ok) {\n *     console.log(`Welcome ${auth.friendlyName}!`);\n *     console.log(`Subscription active: ${auth.activeSubscription}`);\n *   }\n * }\n *\n * // Clean up when done\n * auth.destroy();\n * ```\n */\nexport interface TonkAuthClient {\n  // Authentication State\n\n  /**\n   * Whether the user is currently signed in to Clerk\n   * @readonly\n   * @type {boolean}\n   */\n  readonly isSignedIn: boolean;\n\n  /**\n   * Whether the user has an active subscription\n   * This is checked periodically and cached for performance\n   * @readonly\n   * @type {boolean}\n   */\n  readonly activeSubscription: boolean;\n\n  // User Information\n\n  /**\n   * User's primary email address\n   * Returns \"unknown\" if not available\n   * @readonly\n   * @type {string}\n   */\n  readonly email: string;\n\n  /**\n   * User's display name for friendly greeting\n   * Fallback order: firstName → lastName → username → email\n   * Returns null when user is not authenticated\n   * @readonly\n   * @type {string | null}\n   */\n  readonly friendlyName: string | null;\n\n  /**\n   * Current library version from package.json\n   * @readonly\n   * @type {string}\n   */\n  readonly version: string;\n\n  // Advanced Access (for debugging)\n\n  /**\n   * Direct access to Clerk user resource\n   * ⚠️ Advanced usage only - for debugging or direct Clerk API access\n   * @readonly\n   * @type {UserResource | null}\n   */\n  readonly __user: UserResource | null;\n\n  /**\n   * Direct access to Clerk session resource\n   * ⚠️ Advanced usage only - for debugging or direct Clerk API access\n   * @readonly\n   * @type {SessionResource | null}\n   */\n  readonly __session: SessionResource | null;\n\n  // Methods\n\n  /**\n   * Authenticate user via browser and check subscription status\n   *\n   * Opens a browser window for OAuth authentication, then automatically\n   * checks the user's subscription status and caches the result.\n   *\n   * @returns {Promise<Result<{data: UserResource | null | undefined, subscription: boolean}, Error>>}\n   *   Result containing user data and subscription status, or error details\n   *\n   * @example\n   * ```typescript\n   * const result = await auth.login();\n   * if (result.ok) {\n   *   console.log(`Logged in as: ${result.value.data?.firstName}`);\n   *   console.log(`Has subscription: ${result.value.subscription}`);\n   * } else {\n   *   console.error('Login failed:', result.error.message);\n   * }\n   * ```\n   */\n  login(): Promise<\n    Result<\n      { data: UserResource | null | undefined; subscription: boolean },\n      Error\n    >\n  >;\n\n  /**\n   * Sign out user and clear all stored authentication data\n   *\n   * Clears Clerk session, local token cache, and resets subscription status.\n   * This is a complete cleanup that ensures no authentication data remains.\n   *\n   * @returns {Promise<Result<string, Error>>} Success message or error details\n   *\n   * @example\n   * ```typescript\n   * const result = await auth.logout();\n   * if (result.ok) {\n   *   console.log(result.value); // \"Logged out successfully\"\n   * } else {\n   *   console.error('Logout failed:', result.error.message);\n   * }\n   * ```\n   */\n  logout(): Promise<Result<string, Error>>;\n\n  /**\n   * Clean up resources and stop periodic subscription checks\n   *\n   * Call this when you're done with the TonkAuth instance to prevent\n   * memory leaks from the periodic subscription check interval.\n   * This does NOT log out the user.\n   *\n   * @returns {void}\n   *\n   * @example\n   * ```typescript\n   * // Clean up when your app shuts down\n   * process.on('SIGINT', () => {\n   *   auth.destroy();\n   *   process.exit(0);\n   * });\n   * ```\n   */\n  destroy(): void;\n}\n\n/**\n * Create a new TonkAuth client instance\n *\n * Factory function that creates and initializes a TonkAuth client for handling\n * CLI authentication and subscription management. The client automatically\n * handles token caching, periodic subscription checks, and provides a clean\n * API for login/logout operations.\n *\n * @async\n * @function TonkAuth\n * @param {TonkAuthOptions} [options={}] - Configuration options for the client\n * @returns {Promise<TonkAuthClient>} Promise that resolves to an initialized TonkAuth client\n * @throws {Error} Throws if client initialization fails\n *\n * @example\n * ```typescript\n * import { TonkAuth } from 'tonk-auth';\n *\n * // Basic usage with default options\n * const auth = await TonkAuth();\n *\n * // Advanced configuration\n * const auth = await TonkAuth({\n *   // Handle subscription expiration gracefully\n *   onSubscriptionDisabled: () => {\n *     console.log('⚠️ Subscription expired! Please upgrade to continue.');\n *     process.exit(1);\n *   },\n *\n *   // Check subscription status every 30 seconds\n *   checkInterval: 30 * 1000,\n *\n *   // Be more aggressive with retries\n *   retryAttempts: 5,\n *   retryDelay: 500\n * });\n *\n * // Use the client\n * if (!auth.isSignedIn) {\n *   const result = await auth.login();\n *   if (result.ok) {\n *     console.log(`Welcome back, ${auth.friendlyName}!`);\n *   }\n * }\n *\n * // Clean up when done (important for CLI apps)\n * process.on('SIGINT', () => {\n *   auth.destroy();\n *   process.exit(0);\n * });\n * ```\n *\n * @example\n * ```typescript\n * // Error handling\n * try {\n *   const auth = await TonkAuth();\n *\n *   // Check if user has valid subscription\n *   if (!auth.activeSubscription) {\n *     console.log('No active subscription found');\n *     const loginResult = await auth.login();\n *\n *     if (loginResult.ok && !loginResult.value.subscription) {\n *       console.log('Please upgrade your subscription to use this feature');\n *       return;\n *     }\n *   }\n *\n *   console.log(`✅ Ready to go, ${auth.friendlyName}!`);\n * } catch (error) {\n *   console.error('Failed to initialize TonkAuth:', error);\n *   process.exit(1);\n * }\n * ```\n *\n * @since 1.0.0\n */\nexport async function TonkAuth(\n  options: TonkAuthOptions = {},\n): Promise<TonkAuthClient> {\n  const auth = new _TonkAuth(options);\n  while (!auth.__initialized) {\n    await new Promise((resolve) => setTimeout(resolve, 1));\n  }\n  return auth;\n}\n","/**\n * Utility functions for working with Result types\n */\n\n/**\n * Represents a successful result\n */\nexport type Ok<T> = {\n  ok: true;\n  value: T;\n};\n\n/**\n * Represents an error result\n */\nexport type Err<E> = {\n  ok: false;\n  error: E;\n};\n\n/**\n * A Result type that can be either Ok or Err\n */\nexport type Result<T, E> = Ok<T> | Err<E>;\n\n/**\n * Create a successful Result\n */\nexport const ok = <T>(value: T): Ok<T> => ({ ok: true, value });\n\n/**\n * Create an error Result\n */\nexport const err = <E>(error: E): Err<E> => ({ ok: false, error });\n\n/**\n * Type guard to check if Result is Ok\n */\nexport const isOk = <T, E>(result: Result<T, E>): result is Ok<T> => result.ok;\n\n/**\n * Type guard to check if Result is Err\n */\nexport const isErr = <T, E>(result: Result<T, E>): result is Err<E> =>\n  !result.ok;\n","export function delay(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","{\n  \"name\": \"@tonk/tonk-auth\",\n  \"module\": \"src/index.test.ts\",\n  \"type\": \"module\",\n  \"version\": \"0.2.2\",\n  \"private\": false,\n  \"files\": [\n    \"dist\"\n  ],\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\"\n    }\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"*\": [\n        \"./dist/index.d.ts\"\n      ]\n    }\n  },\n  \"devDependencies\": {\n    \"@biomejs/biome\": \"^2.0.5\",\n    \"@clerk/types\": \"^4.60.1\",\n    \"@types/node\": \"latest\",\n    \"dotenv\": \"^16.5.0\",\n    \"dotenv-cli\": \"^8.0.0\",\n    \"kleur\": \"^4.1.5\",\n    \"oxlint\": \"^1.3.0\",\n    \"tsup\": \"^8.5.0\",\n    \"tsx\": \"^4.20.3\",\n    \"vitest\": \"^3.2.4\"\n  },\n  \"peerDependencies\": {\n    \"typescript\": \"^5\"\n  },\n  \"dependencies\": {\n    \"@clack/prompts\": \"^0.11.0\",\n    \"@clerk/clerk-js\": \"^5.69.0\",\n    \"jose\": \"^6.0.11\",\n    \"keytar\": \"^7.9.0\",\n    \"open\": \"^10.1.2\"\n  },\n  \"scripts\": {\n    \"dev\": \"dotenv -e .env.production tsx src/index.test.ts\",\n    \"dev:local\": \"dotenv -e .env.development.local tsx src/index.test.ts\",\n    \"test\": \"vitest\",\n    \"test:run\": \"vitest run\",\n    \"test:unit\": \"vitest run --exclude='**/build-safety.test.ts'\",\n    \"test:build-safety\": \"pnpm build && vitest run src/__tests__/build-safety.test.ts\",\n    \"build\": \"dotenv -e .env.production tsup\",\n    \"build:release\": \"dotenv -e .env.production pnpm test:unit && pnpm test:build-safety\",\n    \"lint\": \"echo '🦬 Running oxlint...' && oxlint . && echo '\\n\\n🏝️ Running biome...' && biome check\",\n    \"lint:fix\": \"biome check --fix\"\n  },\n  \"keywords\": [\n    \"cli\",\n    \"ai\",\n    \"crdt\",\n    \"local-first\"\n  ],\n  \"engines\": {\n    \"node\": \">=22\"\n  },\n  \"author\": \"tonk-labs\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/tonk-labs/tonk.git\",\n    \"directory\": \"packages/cli\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/tonk-labs/tonk/issues\"\n  },\n  \"homepage\": \"https://github.com/tonk-labs/tonk#readme\"\n}\n","import pkg from \"@clerk/clerk-js/headless/index.js\";\n\nconst { Clerk } = pkg;\n\nimport { createTokenCache } from \"./tokenCache\";\n\n/**\n * @dev Clerk Auth CLI based on https://github.com/clerk/cli-auth-unofficial-example\n */\n\nexport const SERVICE_PREFIX = \"tonk-cli\";\n\nif (!process.env.CLERK_PUBLISHABLE_KEY) {\n  throw new Error(\"CLERK_PUBLISHABLE_KEY environment variable not set\");\n}\n\nconst PUBLISHABLE_KEY = process.env.CLERK_PUBLISHABLE_KEY;\n\nlet clerkInstance: InstanceType<typeof Clerk> = null!;\n\nconst createClerkClient = async (\n  binName = \"tonk-cli\",\n): Promise<InstanceType<typeof Clerk>> => {\n  const serviceName = `${SERVICE_PREFIX}-${binName}`;\n  const tokenCache = await createTokenCache(serviceName);\n\n  if (clerkInstance) return clerkInstance;\n\n  clerkInstance = new Clerk(PUBLISHABLE_KEY);\n\n  clerkInstance.__unstable__onBeforeRequest((req) => {\n    req.credentials = \"omit\";\n    req.url?.searchParams.append(\"_is_native\", \"1\");\n    (req.headers as Headers).set(\"authorization\", tokenCache.getToken() || \"\");\n  });\n\n  clerkInstance.__unstable__onAfterResponse((_, resp) => {\n    const auth = resp?.headers.get(\"authorization\");\n    if (auth) void tokenCache.saveToken(auth);\n  });\n\n  await clerkInstance.load({ standardBrowser: false });\n  return clerkInstance;\n};\n\nawait createClerkClient();\n\nconst clearClerkInstance = async (): Promise<void> => {\n  clerkInstance = await createClerkClient();\n};\n\nexport { clerkInstance as clerkClient, clearClerkInstance };\n","import keytar from \"keytar\";\nimport { clearClerkInstance, SERVICE_PREFIX } from \"./clerkClient\";\n\nexport async function createTokenCache(serviceName: string): Promise<{\n  getToken: () => string | undefined;\n  saveToken: (token: string) => Promise<void>;\n}> {\n  let inMemory: string | null = await keytar.getPassword(\n    serviceName,\n    \"__clerk_client_jwt\",\n  );\n\n  return {\n    getToken: () => inMemory ?? undefined,\n    saveToken: async (token: string) => {\n      inMemory = token;\n      await keytar.setPassword(serviceName, \"__clerk_client_jwt\", token);\n    },\n  };\n}\n\nexport async function createSubscriptionTokenCache(\n  serviceName: string,\n): Promise<{\n  getToken: () => string | undefined;\n  saveToken: (token: string) => Promise<void>;\n  clearToken: () => Promise<void>;\n}> {\n  let inMemory: string | null = await keytar.getPassword(\n    serviceName,\n    \"__subscription_token\",\n  );\n\n  return {\n    getToken: () => inMemory ?? undefined,\n    saveToken: async (token: string) => {\n      inMemory = token;\n      await keytar.setPassword(serviceName, \"__subscription_token\", token);\n    },\n    clearToken: async () => {\n      inMemory = null;\n      try {\n        await keytar.deletePassword(serviceName, \"__subscription_token\");\n      } catch (error) {\n        // Token might not exist, ignore error\n        error as Error;\n      }\n    },\n  };\n}\n\nexport const clearStoredAuth = async (binName = \"tonk-cli\"): Promise<void> => {\n  const serviceName = `${SERVICE_PREFIX}-${binName}`;\n  try {\n    await keytar.deletePassword(serviceName, \"__clerk_client_jwt\");\n    await keytar.deletePassword(serviceName, \"__subscription_token\");\n  } catch (error) {\n    error as Error;\n  }\n\n  // Also clear subscription token\n  try {\n    await keytar.deletePassword(serviceName, \"__subscription_token\");\n  } catch (error) {\n    // Token might not exist, ignore error\n    error as Error;\n  }\n\n  clearClerkInstance();\n};\n","import { createServer, type Server } from \"node:http\";\n\nconst PORT = 1337;\nconst LOCALHOST_REDIRECT_URL: string = `http://127.0.0.1:${PORT}`;\n\nconst successHtml = /* html */ `\n<body>\n  <main style=\"height:100%;width:100%;display:flex;justify-content:center;align-items:center;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;\">\n    <div>\n      <h2>Signed in</h2>\n      <h3 style=\"font-weight: 400;\">You can safely close this tab and return to your terminal</h3>\n    </div>\n  </main>\n</body>\n`;\n\nexport const createLocalhostAuthServer = async (): Promise<{\n  LOCALHOST_REDIRECT_URL: string;\n  listenForAuthRedirect: () => Promise<string>;\n  cleanup: () => void;\n}> => {\n  let currentServer: Server | null = null;\n\n  const listenForAuthRedirect = (): Promise<string> => {\n    return new Promise<string>((resolve, reject) => {\n      const server = createServer((req, res) => {\n        const url = new URL(req.url || \"\", LOCALHOST_REDIRECT_URL);\n        const token = url.searchParams.get(\"token\") ?? \"\";\n\n        // Send the success page back to the browser\n        res.writeHead(200, { \"Content-Type\": \"text/html\" });\n        res.end(successHtml);\n\n        queueMicrotask(() => {\n          resolve(token);\n          server.close(() => {\n            currentServer = null;\n          });\n        });\n      });\n\n      currentServer = server;\n\n      server.on(\"error\", (err: NodeJS.ErrnoException) => {\n        if (err.code === \"EADDRINUSE\") {\n          // Port is in use, reject immediately to allow retry logic\n          reject(new Error(`Port ${PORT} is already in use`));\n        } else {\n          reject(err);\n        }\n      });\n\n      server.listen(PORT);\n\n      const close = () => {\n        if (currentServer) {\n          currentServer.close(() => {\n            currentServer = null;\n          });\n        }\n      };\n\n      process.once(\"SIGINT\", close);\n      process.once(\"SIGTERM\", close);\n    });\n  };\n\n  const cleanup = () => {\n    if (currentServer) {\n      currentServer.close(() => {\n        currentServer = null;\n      });\n    }\n  };\n\n  return { LOCALHOST_REDIRECT_URL, listenForAuthRedirect, cleanup };\n};\n"],"mappings":"AAAA,OAAS,mBAAAA,MAAuB,SAMhC,OAA0B,aAAAC,MAAiB,OAC3C,OAAOC,MAAU,OCqBV,IAAMC,EAASC,IAAqB,CAAE,GAAI,GAAM,MAAAA,CAAM,GAKhDC,EAAUC,IAAsB,CAAE,GAAI,GAAO,MAAAA,CAAM,GCjCzD,SAASC,EAAMC,EAA2B,CAC/C,OAAO,IAAI,QAASC,GAAY,WAAWA,EAASD,CAAE,CAAC,CACzD,CCEE,IAAAE,EAAW,QCJb,OAAOC,MAAS,oCCAhB,OAAOC,MAAY,SAGnB,eAAsBC,EAAiBC,EAGpC,CACD,IAAIC,EAA0B,MAAMC,EAAO,YACzCF,EACA,oBACF,EAEA,MAAO,CACL,SAAU,IAAMC,GAAY,OAC5B,UAAW,MAAOE,GAAkB,CAClCF,EAAWE,EACX,MAAMD,EAAO,YAAYF,EAAa,qBAAsBG,CAAK,CACnE,CACF,CACF,CAEA,eAAsBC,EACpBJ,EAKC,CACD,IAAIC,EAA0B,MAAMC,EAAO,YACzCF,EACA,sBACF,EAEA,MAAO,CACL,SAAU,IAAMC,GAAY,OAC5B,UAAW,MAAOE,GAAkB,CAClCF,EAAWE,EACX,MAAMD,EAAO,YAAYF,EAAa,uBAAwBG,CAAK,CACrE,EACA,WAAY,SAAY,CACtBF,EAAW,KACX,GAAI,CACF,MAAMC,EAAO,eAAeF,EAAa,sBAAsB,CACjE,OAASK,EAAO,CAGhB,CACF,CACF,CACF,CAEO,IAAMC,EAAkB,MAAOC,EAAU,aAA8B,CAC5E,IAAMP,EAAc,GAAGQ,CAAc,IAAID,CAAO,GAChD,GAAI,CACF,MAAML,EAAO,eAAeF,EAAa,oBAAoB,EAC7D,MAAME,EAAO,eAAeF,EAAa,sBAAsB,CACjE,OAASK,EAAO,CAEhB,CAGA,GAAI,CACF,MAAMH,EAAO,eAAeF,EAAa,sBAAsB,CACjE,OAASK,EAAO,CAGhB,CAEAI,EAAmB,CACrB,EDnEA,GAAM,CAAE,MAAAC,CAAM,EAAIC,EAQLC,EAAiB,WAMxBC,EAAkB,+BAEpBC,EAA4C,KAE1CC,EAAoB,MACxBC,EAAU,aAC8B,CACxC,IAAMC,EAAc,GAAGL,CAAc,IAAII,CAAO,GAC1CE,EAAa,MAAMC,EAAiBF,CAAW,EAErD,OAAIH,IAEJA,EAAgB,IAAIJ,EAAMG,CAAe,EAEzCC,EAAc,4BAA6BM,GAAQ,CACjDA,EAAI,YAAc,OAClBA,EAAI,KAAK,aAAa,OAAO,aAAc,GAAG,EAC7CA,EAAI,QAAoB,IAAI,gBAAiBF,EAAW,SAAS,GAAK,EAAE,CAC3E,CAAC,EAEDJ,EAAc,4BAA4B,CAACO,EAAGC,IAAS,CACrD,IAAMC,EAAOD,GAAM,QAAQ,IAAI,eAAe,EAC1CC,GAAWL,EAAW,UAAUK,CAAI,CAC1C,CAAC,EAED,MAAMT,EAAc,KAAK,CAAE,gBAAiB,EAAM,CAAC,EAC5CA,EACT,EAEA,MAAMC,EAAkB,EAExB,IAAMS,EAAqB,SAA2B,CACpDV,EAAgB,MAAMC,EAAkB,CAC1C,EEjDA,OAAS,gBAAAU,MAAiC,OAE1C,IAAMC,EAAO,KACPC,EAAiC,oBAAoBD,CAAI,GAEzDE,EAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWlBC,EAA4B,SAInC,CACJ,IAAIC,EAA+B,KAsDnC,MAAO,CAAE,uBAAAH,EAAwB,sBApDH,IACrB,IAAI,QAAgB,CAACI,EAASC,IAAW,CAC9C,IAAMC,EAASR,EAAa,CAACS,EAAKC,IAAQ,CAExC,IAAMC,EADM,IAAI,IAAIF,EAAI,KAAO,GAAIP,CAAsB,EACvC,aAAa,IAAI,OAAO,GAAK,GAG/CQ,EAAI,UAAU,IAAK,CAAE,eAAgB,WAAY,CAAC,EAClDA,EAAI,IAAIP,CAAW,EAEnB,eAAe,IAAM,CACnBG,EAAQK,CAAK,EACbH,EAAO,MAAM,IAAM,CACjBH,EAAgB,IAClB,CAAC,CACH,CAAC,CACH,CAAC,EAEDA,EAAgBG,EAEhBA,EAAO,GAAG,QAAUI,GAA+B,CAC7CA,EAAI,OAAS,aAEfL,EAAO,IAAI,MAAM,QAAQN,CAAI,oBAAoB,CAAC,EAElDM,EAAOK,CAAG,CAEd,CAAC,EAEDJ,EAAO,OAAOP,CAAI,EAElB,IAAMY,EAAQ,IAAM,CACdR,GACFA,EAAc,MAAM,IAAM,CACxBA,EAAgB,IAClB,CAAC,CAEL,EAEA,QAAQ,KAAK,SAAUQ,CAAK,EAC5B,QAAQ,KAAK,UAAWA,CAAK,CAC/B,CAAC,EAWqD,QARxC,IAAM,CAChBR,GACFA,EAAc,MAAM,IAAM,CACxBA,EAAgB,IAClB,CAAC,CAEL,CAEgE,CAClE,ENrDA,IAAMS,EAAgB,6BAEhBC,EAAgB,GAAGD,CAAa,sBAChCE,EAAkB,GAAGF,CAAa,GAClCG,EAAyB,GAAGH,CAAa,2BAMzCI,EAAYC,EAChB,OAAO,KAAK,+lBAA6B,QAAQ,EAAE,SAAS,OAAO,CACrE,EAwFMC,EAAN,KAA0C,CAChC,oBAA+B,GAC/B,SACA,iBAA0C,KAC1C,kBAA4C,KACpD,cAAyB,GAEzB,YAAYC,EAA2B,CAAC,EAAG,CACzC,KAAK,SAAW,CACd,uBAAwBA,EAAQ,yBAA2B,IAAM,CAAC,GAClE,cAAeA,EAAQ,eAAiB,GAAK,IAC7C,cAAeA,EAAQ,eAAiB,EACxC,WAAYA,EAAQ,YAAc,GACpC,EAEA,KAAK,YAAY,CACnB,CAEA,MAAc,aAA6B,CACzC,GAAI,CAEEC,EAAY,SACd,MAAM,KAAK,0BAA0B,EAIvC,KAAK,oBAAoB,EACzB,KAAK,cAAgB,EACvB,OAASC,EAAO,CACd,cAAQ,MAAM,oCAAqCA,CAAK,EAClD,IAAI,MAAM,gCAAgC,CAClD,CACF,CAEQ,qBAA4B,CAC9B,KAAK,kBACP,cAAc,KAAK,gBAAgB,EAGrC,KAAK,iBAAmB,YAAY,SAAY,CAC1CD,EAAY,SACd,MAAM,KAAK,0BAA0B,CAEzC,EAAG,KAAK,SAAS,aAAa,CAChC,CAEA,MAAc,2BAA2C,CACvD,IAAME,EAAQ,MAAMC,EAA6B,UAAU,EACrDC,EAAQF,EAAM,SAAS,EAE7B,GAAIE,EAAO,CACT,IAAMC,EAAS,KAAK,MAAMD,CAAK,EAE/B,GACEC,EAAO,QACP,EAAEA,EAAO,MAAM,KAAOA,EAAO,KAAK,IAAM,KAAK,IAAI,EAAI,KACrD,CACA,KAAK,oBAAsBA,EAAO,OAClC,KAAK,kBAAoBA,EAAO,KAChC,MACF,CACF,CACA,MAAMH,EAAM,WAAW,EACvB,GAAI,CAEF,IAAMI,EAAS,MAAM,KAAK,iCAAiC,EAE3D,GAAIA,EAAO,GAAI,CACb,IAAMC,EAAY,KAAK,oBACvB,KAAK,oBAAsBD,EAAO,MAAM,OACxC,KAAK,kBAAoBA,EAAO,MAAM,KACtC,MAAMJ,EAAM,WAAW,EACnBI,EAAO,MAAM,MACf,MAAMJ,EAAM,UAAU,KAAK,UAAUI,EAAO,KAAK,CAAC,EAIhDC,GAAa,CAAC,KAAK,qBACrB,KAAK,SAAS,uBAAuB,CAEzC,MAEE,QAAQ,KACN,wCACAD,EAAO,MAAM,QACb,OAAOd,CAAa,GACtB,CAEJ,OAASS,EAAO,CACd,QAAQ,KAAK,sCAAuCA,CAAK,CAC3D,CACF,CAEA,MAAc,kCAEZ,CACA,QAASO,EAAU,EAAGA,GAAW,KAAK,SAAS,cAAeA,IAC5D,GAAI,CACF,IAAMF,EAAS,MAAM,KAAK,wBAAwB,EAMlD,GALIA,EAAO,IAMTA,EAAO,MAAM,QAAQ,SAAS,yBAAyB,GACvDA,EAAO,MAAM,QAAQ,SAAS,gCAAgC,EAE9D,OAAOA,EAIT,GAAIA,EAAO,MAAM,QAAQ,SAAS,uBAAuB,EACvD,MAAO,CACL,GAAI,GACJ,MAAO,CACL,OAAQ,GACR,KAAM,IACR,CACF,EAIF,GAAIE,EAAU,KAAK,SAAS,cAAe,CACzC,MAAMC,EAAM,KAAK,SAAS,WAAaD,CAAO,EAC9C,QACF,CAEA,OAAOF,CACT,OAASL,EAAO,CACd,GAAIO,IAAY,KAAK,SAAS,cAC5B,OAAOE,EAAIT,CAAc,EAE3B,MAAMQ,EAAM,KAAK,SAAS,WAAaD,CAAO,CAChD,CAGF,OAAOE,EAAI,IAAI,MAAM,6BAA6B,CAAC,CACrD,CAEA,MAAc,yBAEZ,CACA,GAAI,CACF,IAAMC,EAAQX,EAEd,GAAI,CAACW,EAAM,QACT,OAAOD,EAAI,IAAI,MAAM,yBAAyB,CAAC,EAGjD,IAAME,EAAU,MAAMD,EAAM,QAAQ,SAAS,EAC7C,GAAI,CAACC,EACH,OAAOF,EAAI,IAAI,MAAM,gCAAgC,CAAC,EAGxD,IAAMG,EAAM,MAAM,MAAMlB,EAAwB,CAC9C,OAAQ,MACR,QAAS,CACP,eAAgB,mBAChB,cAAe,UAAUiB,CAAO,EAClC,CACF,CAAC,EAED,GAAI,CAACC,EAAI,GACP,OAAOH,EAAI,IAAI,MAAM,wBAAwBG,EAAI,MAAM,EAAE,CAAC,EAG5D,IAAMC,EAAgB,MAAMD,EAAI,KAAK,EAQrC,GAAIC,EAAa,SAAW,IAC1B,OAAOC,EAAG,CAAE,OAAQ,GAAO,KAAM,IAAK,CAAC,EAGzC,GAAI,CAACD,EAAa,MAChB,OAAOJ,EAAI,IAAI,MAAM,sBAAsB,CAAC,EAG9C,IAAMN,EAAQU,EAAa,MACrBE,EAAe,MAAM,KAAK,gBAAgBZ,CAAK,EAErD,OAAKY,EAAa,IAKlB,MADc,MAAMC,EAAiB,UAAU,GACnC,UAAUb,CAAK,EAEpBW,EAAGC,EAAa,KAAK,GANnBN,EAAIM,EAAa,KAAK,CAOjC,OAASf,EAAO,CACd,OAAOS,EAAIT,CAAc,CAC3B,CACF,CAEA,MAAc,gBACZiB,EAC4C,CAC5C,GAAI,CACF,GAAM,CAAE,QAAAC,CAAQ,EAAI,MAAMC,EAA2BF,EAAKtB,EAAW,CACnE,SAAU,WACV,OAAQ,CAACF,CAAe,CAC1B,CAAC,EAED,OAAKyB,EAAQ,oBAINJ,EAAG,CAAE,OAAQ,GAAM,KAAMI,CAAQ,CAAC,EAHhCJ,EAAG,CAAE,OAAQ,GAAO,KAAM,IAAK,CAAC,CAI3C,OAASd,EAAO,CACd,OAAOS,EAAIT,CAAc,CAC3B,CACF,CAOA,IAAI,oBAA8B,CAChC,OAAO,KAAK,mBACd,CAEA,IAAI,YAAsB,CACxB,OAAOD,EAAY,UACrB,CAEA,IAAI,OAAgB,CAClB,OAAO,KAAK,QAAQ,qBAAqB,cAAgB,SAC3D,CAEA,IAAI,cAA8B,CAChC,OAAK,KAAK,OAER,KAAK,QAAQ,WACb,KAAK,QAAQ,UACb,KAAK,QAAQ,UACb,KAAK,MALkB,IAO3B,CAEA,IAAI,SAAkB,CACpB,OAAOqB,CACT,CAEA,IAAI,QAA8B,CAChC,OAAOrB,EAAY,MAAQ,IAC7B,CAEA,IAAI,WAAoC,CACtC,OAAOA,EAAY,SAAW,IAChC,CAKA,MAAM,OAEJ,CACA,IAAIsB,EAEO,KAEX,GAAI,CACFA,EAAkB,MAAMC,EAA0B,EAClD,IAAMC,EAAM,UACV,GAAG/B,CAAa,gBAAgB6B,EAAgB,sBAAsB,EACxE,EAEA,MAAMG,EAAKD,CAAG,EACd,IAAMpB,EAAQ,MAAMkB,EAAgB,sBAAsB,EAEpDT,EAAO,MAAMb,EAAY,QAAQ,OAAO,OAAO,CACnD,SAAU,SACV,OAAQI,CACV,CAAC,EAED,OAAKS,EAIDA,EAAI,SAAW,WACVH,EAAI,IAAI,MAAM,0BAA0B,KAAK,UAAUG,CAAG,CAAC,EAAE,CAAC,GAKnEA,EAAI,kBACN,MAAMb,EAAY,UAAU,CAAE,QAASa,EAAI,gBAAiB,CAAC,EAI/D,MAAMb,EAAY,SAAS,OAAO,EAClC,MAAMA,EAAY,QAAQ,OAAO,EAGjC,MAAM,KAAK,0BAA0B,EAE9Be,EAAG,CACR,KAAMf,EAAY,KAClB,aAAc,KAAK,mBACrB,CAAC,GAvBQU,EAAI,IAAI,MAAM,2CAA2C,CAAC,CAwBrE,OAAST,EAAO,CACd,OAAOS,EAAIT,CAAc,CAC3B,QAAE,CAEIqB,GACFA,EAAgB,QAAQ,CAE5B,CACF,CAKA,MAAM,QAAyC,CAC7C,GAAI,CACF,OAAAtB,EAAY,QAAQ,WAAW,EAE3BA,EAAY,SACd,MAAMA,EAAY,QAAQ,EAI5B,MAAM0B,EAAgB,EAGtB,KAAK,oBAAsB,GAC3B,KAAK,kBAAoB,KAElBX,EAAG,yBAAyB,CACrC,OAASd,EAAO,CACd,OAAOS,EAAIT,CAAc,CAC3B,CACF,CAKA,SAAgB,CACV,KAAK,mBACP,cAAc,KAAK,gBAAgB,EACnC,KAAK,iBAAmB,KAE5B,CACF,EAiPA,eAAsB0B,EACpB5B,EAA2B,CAAC,EACH,CACzB,IAAM6B,EAAO,IAAI9B,EAAUC,CAAO,EAClC,KAAO,CAAC6B,EAAK,eACX,MAAM,IAAI,QAASC,GAAY,WAAWA,EAAS,CAAC,CAAC,EAEvD,OAAOD,CACT","names":["createPublicKey","jwtVerify","open","ok","value","err","error","delay","ms","resolve","version","pkg","keytar","createTokenCache","serviceName","inMemory","keytar","token","createSubscriptionTokenCache","error","clearStoredAuth","binName","SERVICE_PREFIX","clearClerkInstance","Clerk","pkg","SERVICE_PREFIX","PUBLISHABLE_KEY","clerkInstance","createClerkClient","binName","serviceName","tokenCache","createTokenCache","req","_","resp","auth","clearClerkInstance","createServer","PORT","LOCALHOST_REDIRECT_URL","successHtml","createLocalhostAuthServer","currentServer","resolve","reject","server","req","res","token","err","close","TONK_BASE_URL","TONK_AUTH_URL","EXPECTED_ISSUER","TOKEN_SUBSCRIPTION_URL","publicKey","createPublicKey","_TonkAuth","options","clerkInstance","error","cache","createSubscriptionTokenCache","token","status","result","wasActive","attempt","delay","err","clerk","session","res","responseData","ok","verifyResult","createTokenCache","raw","payload","jwtVerify","version","localhostServer","createLocalhostAuthServer","url","open","clearStoredAuth","TonkAuth","auth","resolve"]}