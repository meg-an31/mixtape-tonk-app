import path from 'path';
import fs from 'fs';
import envPaths from 'env-paths';
export class RootNode {
    configPath;
    constructor(configPath = '') {
        if (configPath === '') {
            this.configPath = path.join(envPaths('tonk').data, 'root.json');
        }
        else {
            this.configPath = configPath;
        }
    }
    getRootIdFilePath() {
        return this.configPath;
    }
    async getRootId() {
        try {
            // Attempt to read the rootId from file
            const content = await fs.promises.readFile(this.getRootIdFilePath(), 'utf8');
            const data = JSON.parse(content);
            return data.rootId;
        }
        catch (error) {
            // If file doesn't exist or is invalid, generate a new rootId
            return undefined;
        }
    }
    async setRootId(rootId) {
        // Write rootId to file atomically
        const content = JSON.stringify({ rootId: rootId, timestamp: Date.now() });
        const filePath = this.getRootIdFilePath();
        const tmpPath = `${filePath}.tmp`;
        try {
            // Ensure directory exists
            await fs.promises
                .mkdir(path.dirname(filePath), { recursive: true })
                .catch(() => { });
            // Write to temp file first
            await fs.promises.writeFile(tmpPath, content, 'utf8');
            // Rename is atomic on most filesystems
            await fs.promises.rename(tmpPath, filePath);
        }
        catch (error) {
            console.error('Failed to save rootId:', error);
            // Clean up tmp file if it exists
            try {
                await fs.promises.unlink(tmpPath).catch(() => { });
            }
            catch {
                // Ignore errors during cleanup
            }
        }
    }
}
//# sourceMappingURL=rootNode.js.map