import chalk from 'chalk';
class Logger {
    static instance;
    logLevel = 'debug';
    constructor() { }
    static getInstance() {
        if (!Logger.instance) {
            Logger.instance = new Logger();
        }
        return Logger.instance;
    }
    setLogLevel(level) {
        this.logLevel = level;
    }
    getTimestamp() {
        return new Date().toISOString();
    }
    shouldLog(level) {
        const levels = ['debug', 'info', 'warn', 'error'];
        return levels.indexOf(level) >= levels.indexOf(this.logLevel);
    }
    debug(message, ...args) {
        if (this.shouldLog('debug')) {
            console.log(chalk.gray(`[${this.getTimestamp()}] DEBUG:`), message, ...args);
        }
    }
    info(message, ...args) {
        if (this.shouldLog('info')) {
            console.log(chalk.blue(`[${this.getTimestamp()}] INFO:`), message, ...args);
        }
    }
    warn(message, ...args) {
        if (this.shouldLog('warn')) {
            console.log(chalk.yellow(`[${this.getTimestamp()}] WARN:`), message, ...args);
        }
    }
    error(message, ...args) {
        if (this.shouldLog('error')) {
            const errorMessage = message instanceof Error ? message.stack || message.message : message;
            console.error(chalk.red(`[${this.getTimestamp()}] ERROR:`), errorMessage, ...args);
        }
    }
    // Add a method to format objects for better logging
    formatObject(obj) {
        if (obj instanceof Uint8Array) {
            return `Uint8Array(${obj.length})`;
        }
        return obj;
    }
    debugWithContext(context, message, ...args) {
        if (this.shouldLog('debug')) {
            const formattedArgs = args.map(arg => this.formatObject(arg));
            console.log(chalk.gray(`[${this.getTimestamp()}] DEBUG [${context}]:`), message, ...formattedArgs);
        }
    }
}
// Export a singleton instance
export const logger = Logger.getInstance();
//# sourceMappingURL=logger.js.map